//! Point Scalar Multiplication in Binary Circuit
//! Implementation referenced from "Efficient Arithmetic on Koblitz Curves - Jerome A. Solinas" and xs233-sys

const TAU_ADIC_LEN: usize = 470;

/// Tau-adic representation: k = Sum u_i τ^i
/// A scalar is represented by sum of powers of τ, u_i here can be 0 or 1
/// For a 232 bit scalar field element, i ranges over twice that value i.e. 232x2
/// We use this representation with windowed point scalar multiplication, we have found that window size of 5 digits is optimal,
/// therefore multiple of 5 greater than 232x2 = 470 is chosen as `TAU_ADIC_LEN`
///
/// solinas2000 provides algorithm for windowed tau-adic NAF
/// xs233-sys has implementation also for windowed tau-adic NAF
/// However our implementation for now follows windowed tau-adic representation only.
///
/// Algorithm: Repeated Division by tau.
/// Much the same way a decimal number can be converted into binary digits by repeateded division by 2,
/// we can convert an integer into tau-adic representation by repeatedly dividing by tau and taking remainder sequence as result
/// solinas2000 explains when a number is divisible by tau and how to collect its remainder as the result.
///
/// The element c_0 + c_1 τ is divisible by τ if and only if c_0 is even. If it is divisble by τ, remainder is 0, else 1.
/// So LSB of c_0 gives the remainder, which is collected to get the output.
/// Rule for division: (c_0 + c_1 τ) / τ = (c1 - c0/2) + (-c_0/2) τ
///
/// With tau adic representation, you can substitute point doubling in double-and-add algorithm with squaring operation,
/// which is linear and only uses XOR gates
mod tau_adic_repr {
    use super::super::fr_ckt::FR_LEN;
    use super::super::{builder::CircuitTrait, fr_ckt::Fr};
    use super::TAU_ADIC_LEN;

    #[cfg(test)]
    pub(crate) fn tau_adic_repr_bits(k_bits: &[u8; FR_LEN]) -> [u8; TAU_ADIC_LEN] {
        // full‑adder for one bit returning (sum, carry)
        let full_add = |x: u8, y: u8, c: u8| -> (u8, u8) {
            let sum = x ^ y ^ c;
            let carry = (x & y) | (x & c) | (y & c);
            (sum, carry)
        };

        // add two W‑bit vectors, two‑complement
        let add_vec = |x: &Vec<u8>, y: &Vec<u8>| -> Vec<u8> {
            let mut out = vec![0u8; FR_LEN];
            let mut carry = 0u8;
            for i in 0..FR_LEN {
                let (s, c) = full_add(x[i], y[i], carry);
                out[i] = s;
                carry = c; // discard carry while working with 2's complement
            }
            out
        };

        // negate two‑complement via NOT + 1
        let negate = |v: &Vec<u8>| -> Vec<u8> {
            // invert
            let mut inv: Vec<u8> = v.iter().map(|b| 1 ^ *b).collect();
            // add 1
            let mut carry = 1u8;
            for inv_i in inv.iter_mut().take(FR_LEN) {
                let (s, c) = full_add(*inv_i, 0, carry);
                *inv_i = s;
                carry = c; // discard carry while working with 2's complement
            }
            inv
        };

        // arithmetic right‑shift by 1 (sign‑extend)
        let arith_shift_right = |v: &Vec<u8>| -> Vec<u8> {
            let mut out = vec![0u8; FR_LEN];
            out[..(FR_LEN - 1)].copy_from_slice(&v[1..((FR_LEN - 1) + 1)]);
            out[FR_LEN - 1] = v[FR_LEN - 1]; // sign bit (MSB) of 'v' in 2's complement form remains the same
            out
        };

        // subtract 1 (only used when u == 1)
        let sub_one = |v: &mut Vec<u8>| {
            let mut borrow = 1u8;
            for bit in v.iter_mut() {
                let new_bit = *bit ^ borrow; // XOR performs bit‑ subtraction
                borrow &= !*bit; // borrow propagates if bit was 0
                *bit = new_bit;
                if borrow == 0 {
                    break;
                }
            }
        };

        // -----------------------------------------------------------------------
        // Registers c0, c1  (two‑complement)
        let mut c0: Vec<u8> = k_bits.to_vec(); // copy input bits LSB‑first
        let mut c1: Vec<u8> = vec![0u8; FR_LEN];

        // output digits
        let mut out = [0u8; TAU_ADIC_LEN];

        // Element c0 + c1 \tau is divisible by \tau if an only if c0 is even
        for out_r in out.iter_mut().take(TAU_ADIC_LEN) {
            let u = c0[0]; // LSB
            *out_r = u;

            if u == 1 {
                // c0 is odd
                sub_one(&mut c0); // c0 <- c0 - u
            }

            let half = arith_shift_right(&c0);
            let d = negate(&half); // -c0/2

            let c = add_vec(&c1, &d); // c1 + \mew c0/2 => c1 - c0/2

            c0 = c;
            c1 = d;
        }
        out
    }

    fn full_add<T: CircuitTrait>(b: &mut T, x: usize, y: usize, c: usize) -> (usize, usize) {
        let t = b.xor_wire(x, y); // x ⊕ y
        let sum = b.xor_wire(t, c); // SUM  = x ⊕ y ⊕ c

        /* majority: carry = (x&y) ⊕ (c&(x ⊕ y))  —  2 ANDs */
        let a1 = b.and_wire(x, y); // x & y
        let a2 = b.and_wire(c, t); // c & (x⊕y)
        let carry = b.xor_wire(a1, a2);

        (sum, carry)
    }

    // ★ HALF-ADDER : 1 AND
    fn half_add<T: CircuitTrait>(b: &mut T, x: usize, c: usize) -> (usize, usize) {
        (b.xor_wire(x, c), b.and_wire(x, c))
    }

    /* c = a + d     and     nz =  OR_i (c_i | d_i)     */
    fn add_vec_with_flag<T: CircuitTrait>(b: &mut T, a: &Fr, d: &Fr) -> Fr {
        let mut out = [b.zero(); FR_LEN];
        let mut carry = b.zero();

        for i in 0..FR_LEN {
            let (s, c) = full_add(b, a[i], d[i], carry);
            out[i] = s;
            carry = c;
        }
        out
    }

    /* NOT + 1  (two-complement negate) */
    fn negate<T: CircuitTrait>(b: &mut T, v: &Fr) -> Fr {
        let ones = b.one(); // broadcast 1
        let mut inv = [b.zero(); FR_LEN];
        for i in 0..FR_LEN {
            inv[i] = b.xor_wire(v[i], ones);
        } // bitwise NOT
        // +1 with half-adder chain (1 AND / bit) ★
        let mut carry = b.one();
        for inv_i in inv.iter_mut().take(FR_LEN) {
            let (s, c) = half_add(b, *inv_i, carry);
            *inv_i = s;
            carry = c;
        }
        inv
    }
    /* arithmetic right-shift by one (sign extend) */
    fn arith_shift_right<T: CircuitTrait>(bld: &mut T, v: &Fr) -> Fr {
        let mut out = [bld.zero(); FR_LEN];
        out[..(FR_LEN - 1)].copy_from_slice(&v[1..((FR_LEN - 1) + 1)]);
        out[FR_LEN - 1] = v[FR_LEN - 1];
        out
    }

    fn sub_bit<T: CircuitTrait>(a: &mut Fr, u: usize, b: &mut T) {
        let mut borrow = u; // 0 or 1 wire
        let one_gate = b.one();
        for bit in a.iter_mut() {
            // sum   = bit ⊕ borrow
            // carry = (¬bit) ∧ borrow
            let sum = b.xor_wire(*bit, borrow);
            let nbit = b.xor_wire(*bit, one_gate); // ¬bit
            let carry = b.and_wire(nbit, borrow);

            *bit = sum;
            borrow = carry;
            // optional early exit (borrow == 0) is legal but not required
        }
    }

    pub(crate) fn emit_tau_adic_repr_bits<T: CircuitTrait>(
        b: &mut T,
        k_bits: &Fr,
    ) -> [usize; TAU_ADIC_LEN] {
        let mut a: Fr = *k_bits;
        let mut breg: Fr = [b.zero(); FR_LEN];
        let mut out = [b.zero(); TAU_ADIC_LEN];

        for out_i in out.iter_mut().take(TAU_ADIC_LEN) {
            /* u = a₀  --------------------------------------------------*/
            let u = a[0];
            *out_i = u;

            /* a ← a − u  (reuse existing helper)                                */
            sub_bit(&mut a, u, b);

            /* d = −((a)>>1)  ----------------------------------------------------*/
            let half = arith_shift_right(b, &a);
            let d = negate(b, &half);

            /* c = b + d   and   nz = OR(c , d)  ------------------------------- */
            let c = add_vec_with_flag(b, &breg, &d);

            a = c;
            breg = d;
        }
        out
    }

    #[cfg(test)]
    mod test {
        use num_bigint::{BigUint, RandomBits};
        use rand::Rng;

        use crate::circuits::sect233k1::{
            builder::CircuitAdapter,
            curve_scalar_mul_ckt::tau_adic_repr::{emit_tau_adic_repr_bits, tau_adic_repr_bits},
            fr_ref::frref_to_bits,
        };

        use super::*;

        #[test]
        fn test_tau_adic_repr_bits_circuit() {
            let mut rng = rand::thread_rng();
            let k: BigUint = rng.sample(RandomBits::new(232));

            let kbits = {
                let mut k256 = [0u8; FR_LEN];
                let kbits = frref_to_bits(&k).map(|b| b as u8);
                k256[0..FR_LEN].copy_from_slice(&kbits);
                k256
            };

            let rd_ref = tau_adic_repr_bits(&kbits);

            let mut bld = CircuitAdapter::default();

            let mut witness = Vec::<bool>::new();

            let mut k_bits = [0; FR_LEN];
            for i in 0..k_bits.len() {
                k_bits[i] = bld.fresh_one();
                witness.push(kbits[i] & 1 != 0);
            }

            let out_bits = emit_tau_adic_repr_bits(&mut bld, &k_bits);
            let wires = bld.eval_gates(&witness);
            let result: Vec<u8> = out_bits.iter().map(|id| wires[*id] as u8).collect();
            assert_eq!(rd_ref.to_vec(), result);

            let stats = bld.gate_counts();
            println!("{stats}");
        }
    }
}

/// Windowed tau-adic representation works by precomputing a 1 << w sized lookup table with multiples of a CurvePoint per row
mod precompute_table {
    use super::super::{
        builder::{CircuitTrait, Template},
        curve_ckt::{CurvePoint, emit_point_frob},
        gf_ckt::GF_LEN,
    };

    const GENERATOR_X_BYTES: [u8; 30] = [
        0xe6, 0x1b, 0xaa, 0xdd, 0xcb, 0xe5, 0x50, 0xa8, 0x54, 0xbf, 0x66, 0x19, 0x7e, 0xef, 0x24,
        0x57, 0x06, 0xb9, 0x85, 0x65, 0x47, 0xec, 0x3d, 0xfb, 0xd0, 0x76, 0x27, 0xb9, 0xec, 0x01,
    ];
    const GENERATOR_S_BYTES: [u8; 30] = [
        0x99, 0x9a, 0x7d, 0x36, 0xbf, 0xe0, 0xf9, 0x66, 0xc1, 0x96, 0x6f, 0x07, 0x50, 0x32, 0x19,
        0xf7, 0x9d, 0x66, 0xf3, 0xfd, 0xfc, 0x47, 0xaa, 0x5b, 0x4e, 0x4d, 0x3b, 0xff, 0xed, 0x00,
    ];
    const GENERATOR_Z_BYTES: [u8; 30] = [
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    const GENERATOR_T_BYTES: [u8; 30] = GENERATOR_X_BYTES;

    const GENERATOR_TABLE_W5: [[[u8; 30]; 4]; 32] = [
        [
            [
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
            [
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
            [
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
            [
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
        ],
        [
            [
                0xe6, 0x1b, 0xaa, 0xdd, 0xcb, 0xe5, 0x50, 0xa8, 0x54, 0xbf, 0x66, 0x19, 0x7e, 0xef,
                0x24, 0x57, 0x06, 0xb9, 0x85, 0x65, 0x47, 0xec, 0x3d, 0xfb, 0xd0, 0x76, 0x27, 0xb9,
                0xec, 0x01,
            ],
            [
                0x99, 0x9a, 0x7d, 0x36, 0xbf, 0xe0, 0xf9, 0x66, 0xc1, 0x96, 0x6f, 0x07, 0x50, 0x32,
                0x19, 0xf7, 0x9d, 0x66, 0xf3, 0xfd, 0xfc, 0x47, 0xaa, 0x5b, 0x4e, 0x4d, 0x3b, 0xff,
                0xed, 0x00,
            ],
            [
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
            [
                0xe6, 0x1b, 0xaa, 0xdd, 0xcb, 0xe5, 0x50, 0xa8, 0x54, 0xbf, 0x66, 0x19, 0x7e, 0xef,
                0x24, 0x57, 0x06, 0xb9, 0x85, 0x65, 0x47, 0xec, 0x3d, 0xfb, 0xd0, 0x76, 0x27, 0xb9,
                0xec, 0x01,
            ],
        ],
        [
            [
                0xc7, 0xca, 0x58, 0x1e, 0xc0, 0xa5, 0xb6, 0x09, 0xb1, 0x15, 0xe0, 0x28, 0x74, 0x29,
                0x6c, 0x73, 0xf1, 0x62, 0x58, 0xed, 0x16, 0xbe, 0x6b, 0xa3, 0x74, 0xbf, 0xfd, 0xd6,
                0xba, 0x00,
            ],
            [
                0xd1, 0x9a, 0xfe, 0xac, 0x74, 0x4a, 0xcb, 0xd6, 0xab, 0xad, 0x44, 0x17, 0x5d, 0xc8,
                0x60, 0x4b, 0xec, 0x09, 0xbf, 0xc1, 0x7d, 0x96, 0xb7, 0x82, 0x0a, 0x33, 0x24, 0x0f,
                0xc3, 0x01,
            ],
            [
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
            [
                0xc7, 0xca, 0x58, 0x1e, 0xc0, 0xa5, 0xb6, 0x09, 0xb1, 0x15, 0xe0, 0x28, 0x74, 0x29,
                0x6c, 0x73, 0xf1, 0x62, 0x58, 0xed, 0x16, 0xbe, 0x6b, 0xa3, 0x74, 0xbf, 0xfd, 0xd6,
                0xba, 0x00,
            ],
        ],
        [
            [
                0x9c, 0x4b, 0x59, 0xdb, 0x3c, 0x8f, 0x1d, 0xd3, 0xe8, 0xf1, 0xd3, 0x07, 0xc1, 0xaf,
                0x66, 0x27, 0x83, 0x33, 0x05, 0xf1, 0x30, 0x5e, 0x8a, 0x52, 0xc3, 0xea, 0xb5, 0x9a,
                0xf7, 0x00,
            ],
            [
                0x95, 0x31, 0xae, 0xee, 0x9d, 0xe4, 0xd3, 0x37, 0xaf, 0x84, 0xd6, 0xaa, 0x8e, 0xd9,
                0xd0, 0x74, 0xf4, 0x96, 0x36, 0x6c, 0x90, 0xfd, 0x64, 0xc3, 0x8c, 0x33, 0x8b, 0x3b,
                0x99, 0x01,
            ],
            [
                0x19, 0x3f, 0xd5, 0x7c, 0xce, 0x77, 0x4a, 0xa3, 0xfa, 0xf7, 0x69, 0xcc, 0x36, 0xe0,
                0x27, 0x8c, 0x15, 0x41, 0x87, 0x37, 0xf5, 0x1f, 0x88, 0x27, 0xeb, 0xfa, 0x75, 0xc0,
                0x71, 0x00,
            ],
            [
                0x90, 0xf1, 0xd8, 0xd5, 0x65, 0xf8, 0x0e, 0xdd, 0x49, 0xc7, 0x97, 0x38, 0x93, 0x3e,
                0xf1, 0x8d, 0xeb, 0x8d, 0xa7, 0x2e, 0x19, 0x41, 0xc2, 0x0d, 0x51, 0xfb, 0x30, 0x89,
                0x72, 0x00,
            ],
        ],
        [
            [
                0x8a, 0x87, 0x8b, 0x81, 0x3f, 0x07, 0x0f, 0xe5, 0xcd, 0x04, 0x65, 0xf1, 0x53, 0x10,
                0xba, 0x4e, 0x1a, 0x70, 0x90, 0x21, 0xa2, 0xfc, 0x4a, 0x26, 0xb0, 0xb7, 0x63, 0x2e,
                0x52, 0x00,
            ],
            [
                0x8b, 0x76, 0x49, 0x79, 0xfa, 0x20, 0xd0, 0xeb, 0xe2, 0x3c, 0x72, 0x8c, 0xaf, 0x62,
                0x62, 0xda, 0xd9, 0x8c, 0x76, 0xc6, 0x32, 0xb8, 0x3f, 0x8b, 0xf9, 0xb1, 0xc8, 0xd2,
                0x20, 0x00,
            ],
            [
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
            [
                0x8a, 0x87, 0x8b, 0x81, 0x3f, 0x07, 0x0f, 0xe5, 0xcd, 0x04, 0x65, 0xf1, 0x53, 0x10,
                0xba, 0x4e, 0x1a, 0x70, 0x90, 0x21, 0xa2, 0xfc, 0x4a, 0x26, 0xb0, 0xb7, 0x63, 0x2e,
                0x52, 0x00,
            ],
        ],
        [
            [
                0x91, 0x16, 0x0d, 0xe8, 0x70, 0x36, 0xf3, 0x75, 0x91, 0xdf, 0x7e, 0xbb, 0xff, 0x9a,
                0x6f, 0x98, 0x90, 0x09, 0x62, 0x85, 0x28, 0x7d, 0x1a, 0xbc, 0x9a, 0xcb, 0xaf, 0x54,
                0xe6, 0x00,
            ],
            [
                0x19, 0x1c, 0x0e, 0xd7, 0x3d, 0x52, 0xaa, 0x9b, 0xfa, 0xff, 0x33, 0x72, 0xf4, 0x95,
                0x7d, 0x33, 0x4d, 0x87, 0xf4, 0x7d, 0x03, 0xd9, 0x3e, 0xc3, 0xef, 0x32, 0x90, 0x12,
                0x9d, 0x01,
            ],
            [
                0x54, 0xfa, 0x1e, 0x61, 0xaa, 0x05, 0x7a, 0xe6, 0xce, 0x0f, 0xcd, 0x7d, 0x5e, 0xf6,
                0x5d, 0x83, 0xf3, 0xa1, 0x55, 0x27, 0xce, 0xd8, 0xf4, 0x2e, 0x34, 0x37, 0x75, 0xfa,
                0xff, 0x00,
            ],
            [
                0x4b, 0x9c, 0xa3, 0x8b, 0x4c, 0xbf, 0x46, 0x94, 0xac, 0xb5, 0xfd, 0x33, 0x1e, 0x02,
                0x99, 0x86, 0xb8, 0xb6, 0xca, 0xd9, 0x33, 0xfc, 0xa7, 0xb9, 0x01, 0x14, 0x6d, 0xcf,
                0x4c, 0x01,
            ],
        ],
        [
            [
                0x8a, 0x0f, 0x93, 0x03, 0xa4, 0xd7, 0x86, 0x4c, 0x85, 0xed, 0x44, 0x99, 0x1c, 0x3f,
                0x16, 0x7c, 0x17, 0x82, 0x8a, 0xfd, 0x2d, 0x79, 0x17, 0xaa, 0xab, 0x72, 0xfd, 0xec,
                0x34, 0x00,
            ],
            [
                0x79, 0xcc, 0x0e, 0xc8, 0x3e, 0x8b, 0x71, 0x9f, 0x12, 0xc8, 0x2f, 0xea, 0x91, 0x52,
                0x02, 0x9a, 0xf3, 0x49, 0x9d, 0x40, 0xb4, 0x51, 0x64, 0xcc, 0xd4, 0xca, 0xc9, 0x51,
                0x00, 0x01,
            ],
            [
                0x17, 0x6d, 0xa0, 0x9c, 0x84, 0x51, 0x88, 0x1e, 0xe1, 0x82, 0x26, 0x48, 0x89, 0xec,
                0x07, 0x04, 0xcb, 0x8b, 0xbd, 0x7d, 0x49, 0x1c, 0x50, 0xda, 0x9e, 0x85, 0x82, 0xdc,
                0x95, 0x00,
            ],
            [
                0xbb, 0x2c, 0xf4, 0x77, 0xef, 0x38, 0xf1, 0x5f, 0x26, 0xd2, 0x74, 0x20, 0x5f, 0xbc,
                0xff, 0xd2, 0xd2, 0xe4, 0x3d, 0xd8, 0x1f, 0xe1, 0x68, 0xa5, 0x8f, 0xc1, 0xd6, 0x87,
                0x09, 0x01,
            ],
        ],
        [
            [
                0x40, 0x9e, 0x5b, 0x45, 0x8c, 0xbe, 0xd5, 0x47, 0x82, 0x95, 0xae, 0x22, 0x80, 0xdf,
                0x7d, 0xef, 0xf6, 0x44, 0xa4, 0x4f, 0xad, 0x4c, 0xad, 0x06, 0xd0, 0xa6, 0xf9, 0xba,
                0x6b, 0x00,
            ],
            [
                0x5d, 0x98, 0xae, 0xeb, 0x84, 0x09, 0x4b, 0xa2, 0xd6, 0xa5, 0x70, 0xc2, 0x8a, 0x3e,
                0x36, 0x76, 0x07, 0xa3, 0xba, 0x5f, 0x61, 0x16, 0x97, 0x0b, 0x82, 0x3c, 0xa1, 0x78,
                0x6d, 0x01,
            ],
            [
                0x82, 0x3c, 0x49, 0x2a, 0x3f, 0xb3, 0x25, 0xf6, 0x74, 0x51, 0x0e, 0x4a, 0x19, 0x4b,
                0x94, 0x08, 0x76, 0x39, 0x36, 0xd4, 0xde, 0x82, 0xfc, 0x1b, 0xfe, 0x1f, 0xe6, 0x0b,
                0xa9, 0x00,
            ],
            [
                0xae, 0x5e, 0x51, 0x4c, 0x7c, 0x0b, 0xd2, 0x61, 0x5e, 0x09, 0xba, 0x32, 0x41, 0xc2,
                0x52, 0xe4, 0xca, 0xfa, 0x46, 0x79, 0x1d, 0xad, 0xd6, 0xa2, 0x1d, 0x42, 0x56, 0xa0,
                0x0b, 0x01,
            ],
        ],
        [
            [
                0x23, 0x7f, 0x58, 0xe7, 0x51, 0x94, 0x0f, 0xc4, 0xe4, 0x99, 0xea, 0x36, 0xea, 0xfa,
                0x6b, 0x4d, 0x49, 0x9c, 0x10, 0x88, 0xbb, 0x16, 0x03, 0xfd, 0x87, 0x1b, 0x2a, 0x8b,
                0x4c, 0x01,
            ],
            [
                0x1a, 0xe3, 0xf9, 0xf5, 0x39, 0x3c, 0x30, 0x9f, 0x4a, 0x23, 0xa5, 0x30, 0x81, 0x12,
                0x56, 0x3a, 0xaf, 0x4c, 0xd8, 0x05, 0xa6, 0x9f, 0xf2, 0xea, 0xd7, 0xcc, 0xa6, 0x94,
                0x84, 0x00,
            ],
            [
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
            [
                0x23, 0x7f, 0x58, 0xe7, 0x51, 0x94, 0x0f, 0xc4, 0xe4, 0x99, 0xea, 0x36, 0xea, 0xfa,
                0x6b, 0x4d, 0x49, 0x9c, 0x10, 0x88, 0xbb, 0x16, 0x03, 0xfd, 0x87, 0x1b, 0x2a, 0x8b,
                0x4c, 0x01,
            ],
        ],
        [
            [
                0x56, 0xec, 0x0f, 0x19, 0x16, 0x3c, 0x6e, 0xca, 0x71, 0x91, 0x17, 0xb9, 0x15, 0x79,
                0x2d, 0xd4, 0xb0, 0x09, 0x9b, 0x4f, 0x7f, 0x85, 0x7e, 0xa2, 0xd0, 0xad, 0xfb, 0x76,
                0xe8, 0x01,
            ],
            [
                0xe7, 0x85, 0x3d, 0xac, 0xe9, 0xef, 0xc5, 0x39, 0xbb, 0xe1, 0x6f, 0x5a, 0x77, 0x28,
                0x2e, 0x2e, 0x06, 0x99, 0x3e, 0x86, 0x80, 0x4e, 0x66, 0xd2, 0x75, 0xcb, 0xf9, 0x0e,
                0x9d, 0x01,
            ],
            [
                0x44, 0xf9, 0x80, 0x5d, 0xaa, 0xbd, 0x67, 0x30, 0x94, 0x94, 0x2b, 0xc1, 0x9b, 0x3a,
                0xbb, 0x7b, 0x06, 0x75, 0x4c, 0x67, 0xfb, 0x52, 0xe0, 0x1d, 0xe3, 0xab, 0x71, 0x06,
                0x2c, 0x01,
            ],
            [
                0x37, 0xc7, 0xba, 0xaf, 0x2e, 0x84, 0xce, 0x50, 0x46, 0x15, 0x3c, 0x08, 0x78, 0xe2,
                0xcc, 0xf6, 0x08, 0x48, 0xab, 0xf1, 0xe7, 0x91, 0xf7, 0x8d, 0x9a, 0x72, 0xaf, 0x08,
                0xf4, 0x01,
            ],
        ],
        [
            [
                0x4a, 0xa4, 0x64, 0xd4, 0xb5, 0x30, 0x51, 0x42, 0xde, 0x31, 0xa1, 0xe6, 0xd2, 0x6e,
                0xd8, 0xf3, 0x59, 0x91, 0x54, 0x73, 0x74, 0x3f, 0x4f, 0x45, 0xff, 0xdf, 0xec, 0xc1,
                0xf7, 0x00,
            ],
            [
                0x9f, 0x87, 0xd7, 0x29, 0x9d, 0x0e, 0x34, 0x88, 0xba, 0xd4, 0x95, 0x0d, 0x66, 0xc0,
                0x56, 0x6f, 0xa2, 0xf8, 0x5a, 0x55, 0x25, 0x87, 0x84, 0x37, 0x98, 0xdd, 0x9b, 0x49,
                0x5b, 0x01,
            ],
            [
                0x9d, 0x06, 0xe1, 0xc6, 0xeb, 0x45, 0xf6, 0xc9, 0x99, 0x7a, 0x4d, 0xbe, 0x22, 0x4b,
                0x2e, 0x01, 0x09, 0x0d, 0x7c, 0x80, 0x7b, 0x7a, 0x53, 0x3f, 0x7e, 0x19, 0x16, 0xf7,
                0x5b, 0x01,
            ],
            [
                0x65, 0x0a, 0x71, 0xb0, 0x33, 0x9b, 0x37, 0x32, 0xe8, 0x31, 0x95, 0x43, 0xd2, 0x63,
                0xc6, 0x80, 0x3b, 0x05, 0x35, 0xe7, 0x5b, 0xd7, 0x25, 0x87, 0xf4, 0xa3, 0xae, 0xa2,
                0xcb, 0x01,
            ],
        ],
        [
            [
                0x32, 0x8d, 0xf0, 0xa0, 0x8d, 0x25, 0x77, 0x94, 0x9e, 0x5f, 0x97, 0x9b, 0xb4, 0xa8,
                0x7d, 0x38, 0xe4, 0x6d, 0x75, 0x94, 0x35, 0x99, 0x69, 0xba, 0x4c, 0x8f, 0x29, 0x42,
                0x2b, 0x01,
            ],
            [
                0x93, 0x47, 0x33, 0x0e, 0xa4, 0x7b, 0x73, 0x48, 0x56, 0x08, 0x01, 0xdb, 0xf8, 0x7e,
                0x78, 0xec, 0x82, 0x1e, 0x2b, 0x56, 0xf6, 0xab, 0xc4, 0x0d, 0xd9, 0x81, 0x93, 0xb9,
                0xec, 0x00,
            ],
            [
                0x74, 0x8d, 0xda, 0x08, 0x8b, 0xcc, 0xac, 0x08, 0xd0, 0xa5, 0x8b, 0xe7, 0x57, 0x39,
                0x2a, 0xa3, 0x80, 0x8f, 0x2c, 0x27, 0xc3, 0xfd, 0xb1, 0x27, 0x0d, 0x03, 0x49, 0xa0,
                0x19, 0x01,
            ],
            [
                0x87, 0x24, 0x8c, 0xef, 0x6d, 0x79, 0x72, 0x28, 0x10, 0xac, 0x32, 0xab, 0xcf, 0x49,
                0x2b, 0x4e, 0x42, 0xeb, 0xdf, 0x8e, 0x93, 0xa2, 0x6d, 0xd0, 0x6c, 0xae, 0x18, 0xce,
                0x16, 0x00,
            ],
        ],
        [
            [
                0x00, 0xec, 0xca, 0xdb, 0x50, 0x13, 0x71, 0x32, 0xb5, 0xfc, 0x0e, 0x07, 0xf8, 0xb7,
                0x93, 0x4b, 0xd8, 0xf6, 0x51, 0xdc, 0x90, 0x9a, 0x49, 0xc3, 0x50, 0x2b, 0xf7, 0x05,
                0x9c, 0x01,
            ],
            [
                0x10, 0xf3, 0xa0, 0x93, 0xae, 0x21, 0xd9, 0xf8, 0x74, 0x40, 0xd4, 0x0b, 0xac, 0x7e,
                0xda, 0x2d, 0xac, 0xab, 0x6c, 0xf8, 0x5d, 0xac, 0xee, 0x56, 0x89, 0xe9, 0xac, 0xb1,
                0xa4, 0x00,
            ],
            [
                0x54, 0x18, 0x91, 0x32, 0xe8, 0x36, 0xa1, 0xf8, 0xf3, 0xec, 0xee, 0x31, 0xd3, 0x48,
                0x9f, 0x44, 0xee, 0x78, 0x8f, 0xc0, 0x36, 0x2c, 0xc0, 0x10, 0x61, 0xca, 0x70, 0x7e,
                0x9d, 0x00,
            ],
            [
                0x2f, 0xc6, 0x28, 0x92, 0x69, 0x48, 0xff, 0xfc, 0x57, 0x5d, 0xe5, 0x4d, 0xd8, 0xb3,
                0x0a, 0x99, 0x39, 0x07, 0x22, 0xd9, 0x1a, 0x17, 0x2a, 0x26, 0x7d, 0x33, 0xd2, 0xed,
                0x7f, 0x01,
            ],
        ],
        [
            [
                0xe8, 0x06, 0x91, 0x8f, 0x65, 0xbb, 0x1c, 0x86, 0x48, 0xfb, 0x3f, 0x52, 0xc8, 0x90,
                0x49, 0xe6, 0xdf, 0xcc, 0xbc, 0xe5, 0xdf, 0xe7, 0x7f, 0x9c, 0x6e, 0xc1, 0x71, 0x44,
                0x0e, 0x00,
            ],
            [
                0x23, 0xc0, 0x82, 0xa6, 0x80, 0x33, 0x83, 0xec, 0x36, 0x21, 0x8e, 0x78, 0x72, 0x40,
                0x85, 0xca, 0xaf, 0x2b, 0x9b, 0x23, 0xf5, 0xc8, 0x42, 0xf1, 0xf1, 0x54, 0x32, 0x71,
                0x1a, 0x01,
            ],
            [
                0x2a, 0x60, 0xd5, 0xfb, 0x00, 0x65, 0xbb, 0xd9, 0xfe, 0x95, 0x98, 0x30, 0x16, 0x14,
                0xb4, 0x44, 0x55, 0x22, 0x11, 0xf3, 0xb3, 0xba, 0x87, 0x57, 0x85, 0x02, 0xf3, 0x6f,
                0xf5, 0x01,
            ],
            [
                0xe0, 0xb1, 0x84, 0x21, 0x73, 0x18, 0xf1, 0xdc, 0xda, 0x61, 0xb6, 0xee, 0x50, 0x6c,
                0x34, 0x32, 0x68, 0x36, 0x4e, 0xbf, 0x92, 0x81, 0x85, 0x4a, 0x50, 0x57, 0x2b, 0x5a,
                0x02, 0x00,
            ],
        ],
        [
            [
                0xdb, 0x2e, 0x3a, 0x8a, 0x3a, 0x5d, 0x5c, 0x5d, 0xe6, 0x06, 0x27, 0xd5, 0x1e, 0x86,
                0xac, 0x0d, 0x13, 0x93, 0xbb, 0xe1, 0xde, 0xc6, 0x06, 0x84, 0x88, 0x6a, 0xdf, 0x73,
                0x5b, 0x01,
            ],
            [
                0x13, 0xcb, 0xcf, 0x4a, 0x90, 0x06, 0x72, 0xa7, 0xa6, 0xe3, 0xa0, 0x3f, 0x61, 0x8a,
                0x8f, 0x13, 0x78, 0xa8, 0xbf, 0x64, 0x22, 0x95, 0xae, 0x52, 0x4c, 0x62, 0x54, 0x2d,
                0x96, 0x01,
            ],
            [
                0x71, 0x35, 0x51, 0x9b, 0x9f, 0xf5, 0x46, 0xcf, 0x13, 0x59, 0xf8, 0xea, 0x41, 0x7c,
                0xa3, 0xf6, 0x96, 0xac, 0x20, 0x19, 0x56, 0x08, 0x4c, 0x9a, 0x4b, 0x89, 0x4f, 0x32,
                0x9a, 0x01,
            ],
            [
                0x5d, 0x48, 0x6e, 0x27, 0x38, 0xb3, 0x3e, 0x5f, 0xd8, 0x90, 0xff, 0x40, 0x5c, 0x9d,
                0xab, 0x24, 0x41, 0x32, 0x65, 0x82, 0xe6, 0x45, 0xae, 0x07, 0x21, 0xb2, 0xae, 0xfa,
                0x26, 0x01,
            ],
        ],
        [
            [
                0xb3, 0x31, 0x5a, 0x98, 0x2a, 0x33, 0x1b, 0x59, 0x45, 0x6e, 0x40, 0xb4, 0xce, 0xf5,
                0x5b, 0xe9, 0x12, 0x0e, 0xf6, 0x86, 0xbf, 0x3f, 0x96, 0x84, 0x46, 0x12, 0xef, 0x6e,
                0x9d, 0x00,
            ],
            [
                0xa8, 0x59, 0x28, 0x01, 0xf6, 0x6e, 0xea, 0x6d, 0x22, 0x82, 0xc6, 0x8b, 0x69, 0x9b,
                0xf2, 0x74, 0xf0, 0x79, 0x8b, 0xfa, 0xf0, 0xfb, 0x81, 0x9d, 0xe3, 0x2f, 0x40, 0xf5,
                0xbb, 0x00,
            ],
            [
                0xf3, 0xd9, 0xd6, 0x9e, 0x0a, 0xd1, 0x7e, 0x4c, 0x59, 0xae, 0x6e, 0x40, 0xe9, 0xf0,
                0xff, 0x80, 0x3a, 0x6d, 0x1e, 0x81, 0xd8, 0x8e, 0xed, 0x5e, 0x2e, 0xc1, 0x30, 0x0d,
                0x6a, 0x01,
            ],
            [
                0xa9, 0x56, 0x8c, 0xda, 0xf3, 0x2e, 0x25, 0x73, 0x68, 0xf2, 0x19, 0xb6, 0x67, 0xd8,
                0x34, 0x9f, 0x30, 0x82, 0x70, 0x53, 0x0a, 0xc0, 0x53, 0x5a, 0xdb, 0x34, 0x67, 0xcf,
                0x0d, 0x01,
            ],
        ],
        [
            [
                0xcf, 0x69, 0xdc, 0x71, 0x4c, 0xfc, 0x75, 0x84, 0x11, 0x18, 0x07, 0xc6, 0xe5, 0xbb,
                0x24, 0xd1, 0xd1, 0xbf, 0x6f, 0xcb, 0x6e, 0x7c, 0x3c, 0x25, 0xcc, 0x76, 0xc6, 0xd7,
                0xe7, 0x00,
            ],
            [
                0x1d, 0xf3, 0xd7, 0x6a, 0x27, 0x6d, 0x58, 0xe5, 0xa9, 0x69, 0x99, 0x44, 0x59, 0x37,
                0x94, 0xe7, 0xaf, 0x90, 0x8c, 0x8e, 0x11, 0xe4, 0x82, 0x8d, 0x2b, 0x62, 0xac, 0xa1,
                0x1e, 0x01,
            ],
            [
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
            [
                0xcf, 0x69, 0xdc, 0x71, 0x4c, 0xfc, 0x75, 0x84, 0x11, 0x18, 0x07, 0xc6, 0xe5, 0xbb,
                0x24, 0xd1, 0xd1, 0xbf, 0x6f, 0xcb, 0x6e, 0x7c, 0x3c, 0x25, 0xcc, 0x76, 0xc6, 0xd7,
                0xe7, 0x00,
            ],
        ],
        [
            [
                0x65, 0xfe, 0x8c, 0x4f, 0x07, 0xbc, 0x14, 0x09, 0xc1, 0xa2, 0x85, 0x06, 0x34, 0x27,
                0x3c, 0x14, 0xe1, 0x4a, 0x7c, 0xf7, 0x71, 0xf6, 0xe3, 0x36, 0xdc, 0x4a, 0x73, 0x2d,
                0x2b, 0x01,
            ],
            [
                0xfd, 0xfa, 0xf2, 0x0d, 0xa7, 0xe4, 0xbe, 0xc6, 0x78, 0x05, 0xea, 0x89, 0x37, 0x63,
                0x18, 0xdb, 0x67, 0x64, 0xe8, 0x24, 0x6b, 0xf2, 0xbb, 0x8c, 0xed, 0xb0, 0x07, 0x28,
                0x47, 0x00,
            ],
            [
                0x32, 0x4a, 0x77, 0xf0, 0x7c, 0x53, 0x8c, 0x24, 0x61, 0x13, 0xf3, 0x58, 0x6a, 0xa2,
                0xde, 0x0d, 0x80, 0x65, 0x82, 0x98, 0xe7, 0x90, 0x07, 0xe5, 0xf7, 0xa9, 0x60, 0xc6,
                0xdd, 0x00,
            ],
            [
                0xb9, 0xc1, 0xe7, 0x0f, 0xb1, 0x9a, 0x68, 0xa9, 0x48, 0x66, 0x63, 0x81, 0x55, 0xec,
                0x87, 0xf9, 0x37, 0xa5, 0xfa, 0xd8, 0x7f, 0x0f, 0xd7, 0x64, 0xd8, 0x2f, 0x62, 0xb3,
                0x0d, 0x00,
            ],
        ],
        [
            [
                0x47, 0xc8, 0x3c, 0x91, 0xa2, 0x34, 0xd4, 0xe3, 0xe0, 0x66, 0xbd, 0x1c, 0xcb, 0xc3,
                0xb7, 0xae, 0x81, 0xc4, 0x8c, 0xe1, 0x17, 0x03, 0xc1, 0x67, 0x93, 0xa1, 0x43, 0xbd,
                0xfb, 0x00,
            ],
            [
                0x02, 0x3b, 0x43, 0x0b, 0x84, 0xf1, 0x70, 0xbf, 0x02, 0x03, 0xc9, 0x1d, 0x1c, 0x2f,
                0x9a, 0x8c, 0xa3, 0xc8, 0x84, 0x5c, 0xdf, 0xb6, 0x44, 0x91, 0x17, 0x17, 0xc8, 0x0e,
                0xd6, 0x00,
            ],
            [
                0xe6, 0xf7, 0x0f, 0x5e, 0x95, 0xdc, 0x5b, 0x69, 0xc8, 0x97, 0x44, 0xdc, 0x12, 0xc2,
                0x7a, 0x2f, 0x5a, 0xd8, 0xbe, 0x6b, 0x65, 0x8c, 0xab, 0xf2, 0x4f, 0xe3, 0xe6, 0x2f,
                0xcd, 0x01,
            ],
            [
                0x7c, 0x8b, 0x2a, 0x25, 0x00, 0x25, 0xdd, 0x76, 0xa3, 0x21, 0x83, 0xb4, 0x2a, 0xc1,
                0x21, 0xba, 0x74, 0xe4, 0x36, 0x09, 0x5a, 0x2f, 0xc8, 0xa8, 0x48, 0x9f, 0xa6, 0x5c,
                0x72, 0x00,
            ],
        ],
        [
            [
                0xdf, 0x0f, 0xec, 0xa1, 0x65, 0x1a, 0xd7, 0xc7, 0x7d, 0x30, 0x14, 0x81, 0x87, 0xf8,
                0xc4, 0x77, 0x62, 0x9b, 0x45, 0x44, 0x07, 0x9c, 0x32, 0x6a, 0xb1, 0x11, 0x48, 0xd8,
                0x2f, 0x01,
            ],
            [
                0x31, 0xfe, 0x68, 0xdd, 0x58, 0x89, 0x42, 0x63, 0xca, 0x27, 0x9a, 0x37, 0xfb, 0xa7,
                0xcb, 0x80, 0x27, 0x66, 0x3c, 0x2b, 0x97, 0x2a, 0xdb, 0xee, 0xd9, 0x61, 0x87, 0x97,
                0x8e, 0x00,
            ],
            [
                0x09, 0xd5, 0x96, 0xbd, 0x80, 0x0b, 0x44, 0x68, 0x49, 0x34, 0x86, 0x4a, 0x7a, 0x79,
                0xd9, 0xf5, 0x9d, 0x91, 0x93, 0xfd, 0xb4, 0x1b, 0xed, 0x79, 0xc0, 0xdf, 0x6a, 0xd3,
                0x2d, 0x01,
            ],
            [
                0x53, 0xff, 0x28, 0x26, 0x8d, 0xd6, 0x08, 0x62, 0x7b, 0xe1, 0x5c, 0x2d, 0x1a, 0xf4,
                0xe1, 0x1c, 0x75, 0x7b, 0x18, 0x01, 0x47, 0x19, 0x65, 0xe3, 0x23, 0x9b, 0x5e, 0xb3,
                0x24, 0x00,
            ],
        ],
        [
            [
                0xb9, 0xc7, 0xeb, 0xb4, 0xcc, 0x95, 0x60, 0xcc, 0xcc, 0x33, 0x55, 0x62, 0x48, 0xc8,
                0x81, 0xf8, 0xa9, 0x2f, 0x82, 0x85, 0x8b, 0xc4, 0x96, 0x76, 0x04, 0x71, 0xde, 0xbe,
                0xc0, 0x01,
            ],
            [
                0x9c, 0x3a, 0x4e, 0x07, 0x76, 0xb0, 0x7b, 0xe3, 0xc8, 0xec, 0x33, 0x65, 0x8f, 0x82,
                0xe5, 0xa3, 0x78, 0xa8, 0x34, 0xd3, 0x93, 0xe1, 0xd3, 0x22, 0x94, 0xb4, 0xa2, 0xf8,
                0x1c, 0x01,
            ],
            [
                0xc6, 0x00, 0x95, 0x34, 0x80, 0x69, 0x41, 0xbd, 0x5e, 0x09, 0xb7, 0xb7, 0xcc, 0xf3,
                0x3d, 0x86, 0x7c, 0x84, 0x42, 0x3f, 0x51, 0x9a, 0xdc, 0xe5, 0x8e, 0xac, 0x45, 0xb8,
                0x74, 0x00,
            ],
            [
                0x6c, 0x11, 0xa0, 0xf6, 0xc7, 0x19, 0xc4, 0x88, 0xd7, 0xfa, 0xfa, 0x73, 0x46, 0x94,
                0x9f, 0x1d, 0xf5, 0x15, 0x0e, 0x25, 0x31, 0x61, 0x0d, 0x98, 0x04, 0x5b, 0x8d, 0xb6,
                0x9c, 0x00,
            ],
        ],
        [
            [
                0x17, 0x32, 0x58, 0x38, 0xad, 0x37, 0xb1, 0x3b, 0x3b, 0x03, 0x0d, 0x46, 0x40, 0xef,
                0xb0, 0x37, 0x0c, 0xb3, 0x65, 0xc7, 0x31, 0x79, 0x28, 0x20, 0x0f, 0xe4, 0xaf, 0x74,
                0x42, 0x01,
            ],
            [
                0xa9, 0x7b, 0x25, 0xa1, 0x29, 0x59, 0xbf, 0x02, 0xa6, 0x13, 0x76, 0x5c, 0xe2, 0xc8,
                0xc4, 0xaa, 0x13, 0x9e, 0xfa, 0xeb, 0xaa, 0x8d, 0x89, 0x42, 0x9e, 0x6f, 0x13, 0x22,
                0xfa, 0x00,
            ],
            [
                0x8e, 0x70, 0xb1, 0xfd, 0x64, 0x1a, 0xdd, 0x4e, 0xaa, 0x73, 0xcd, 0x9e, 0x7e, 0x6e,
                0xe1, 0x07, 0x13, 0xbe, 0x25, 0x8a, 0x24, 0x3a, 0x38, 0xea, 0x01, 0xc1, 0x8b, 0x8f,
                0xfb, 0x00,
            ],
            [
                0xa7, 0x80, 0x9e, 0x35, 0x4c, 0x76, 0xe8, 0x55, 0x1d, 0xfe, 0x75, 0xd4, 0xd9, 0x9b,
                0xfb, 0x6a, 0xf3, 0x49, 0x56, 0xc9, 0x46, 0x3b, 0x3a, 0x4a, 0x3a, 0xf9, 0x05, 0x09,
                0xb9, 0x00,
            ],
        ],
        [
            [
                0x1e, 0xf0, 0x13, 0x09, 0xae, 0x79, 0x9a, 0x89, 0x5f, 0xa1, 0x65, 0x87, 0xb2, 0x0c,
                0x02, 0x09, 0x68, 0xd8, 0x53, 0xbb, 0xbf, 0x61, 0x67, 0xe3, 0x90, 0x6f, 0x40, 0xec,
                0x73, 0x01,
            ],
            [
                0x5e, 0x68, 0x7f, 0x17, 0x64, 0xee, 0x91, 0x72, 0x46, 0xa2, 0xe8, 0x37, 0xb2, 0xb3,
                0xcf, 0x0f, 0x77, 0x60, 0xe9, 0x82, 0x81, 0xaa, 0x6f, 0x5b, 0xc0, 0x55, 0xd4, 0x3d,
                0xe8, 0x01,
            ],
            [
                0x92, 0x12, 0x73, 0x01, 0xf4, 0x7b, 0x24, 0x69, 0xc6, 0x43, 0xcc, 0xda, 0xfc, 0x2d,
                0x40, 0x10, 0x07, 0x56, 0xbd, 0x64, 0xcf, 0xe2, 0x37, 0xde, 0x1f, 0x9b, 0xc9, 0xad,
                0x66, 0x00,
            ],
            [
                0x03, 0x3e, 0x5c, 0x46, 0xd9, 0x36, 0xaf, 0xea, 0x78, 0x66, 0x19, 0xa6, 0x2d, 0x32,
                0x38, 0xc5, 0xf1, 0x27, 0xd0, 0xec, 0x04, 0xad, 0x6f, 0x6c, 0xf7, 0x52, 0x69, 0x38,
                0xe5, 0x00,
            ],
        ],
        [
            [
                0x70, 0x97, 0x40, 0x22, 0xc5, 0xba, 0xb4, 0xa8, 0x41, 0x22, 0x07, 0xb6, 0xd6, 0xb3,
                0xbc, 0xbf, 0xb8, 0xa1, 0xaa, 0xec, 0x34, 0x70, 0x9a, 0xb1, 0xf0, 0x6d, 0x22, 0x2c,
                0x7b, 0x01,
            ],
            [
                0x8c, 0x11, 0x2c, 0x2d, 0x2a, 0x53, 0x99, 0x9b, 0xa5, 0x85, 0xf9, 0x43, 0x86, 0x8d,
                0x24, 0x92, 0x79, 0x5a, 0x3a, 0x3c, 0xc8, 0x0f, 0x9b, 0x7f, 0xd9, 0x0f, 0x67, 0x25,
                0x5c, 0x00,
            ],
            [
                0xa9, 0xc3, 0xf7, 0xc1, 0x0d, 0x84, 0x68, 0xdf, 0x6f, 0xc9, 0xdf, 0xd2, 0xca, 0x04,
                0xc5, 0x55, 0x97, 0x8e, 0x2f, 0x63, 0x42, 0x89, 0xca, 0x71, 0x55, 0x50, 0x69, 0x9f,
                0x68, 0x01,
            ],
            [
                0xea, 0x99, 0x2a, 0x48, 0x8b, 0x41, 0xc9, 0x35, 0xd4, 0x7a, 0x8d, 0x39, 0xa7, 0x02,
                0x71, 0x37, 0xf0, 0x30, 0x81, 0x93, 0x65, 0xd3, 0x22, 0x64, 0x1e, 0x06, 0xab, 0xd4,
                0x88, 0x00,
            ],
        ],
        [
            [
                0xb1, 0x67, 0x5c, 0xe1, 0x39, 0xcb, 0xef, 0x81, 0x49, 0x7c, 0xb3, 0xb0, 0xf5, 0x41,
                0xc9, 0x8f, 0xdb, 0x60, 0xdd, 0x77, 0xdc, 0xa0, 0x1f, 0x08, 0x68, 0x7d, 0x1f, 0x4d,
                0xa5, 0x01,
            ],
            [
                0xe8, 0x68, 0x53, 0x2d, 0xe6, 0x67, 0x62, 0x79, 0x1a, 0x44, 0x0c, 0xf5, 0xa8, 0xe0,
                0xed, 0xe3, 0xdb, 0xa7, 0x09, 0x9a, 0x12, 0x53, 0xcf, 0xa0, 0x5a, 0x6c, 0x5e, 0x3f,
                0xe4, 0x01,
            ],
            [
                0x24, 0x5d, 0x18, 0x2b, 0x3e, 0xb5, 0x9b, 0x7e, 0x21, 0x84, 0x0c, 0xee, 0xaa, 0x90,
                0x92, 0x2a, 0xc3, 0x50, 0xd1, 0xf4, 0x76, 0x7c, 0x89, 0x8d, 0x0f, 0x5b, 0xca, 0xba,
                0x77, 0x01,
            ],
            [
                0xc0, 0xa1, 0xb1, 0xf4, 0x93, 0x5f, 0x50, 0x16, 0xd6, 0xe1, 0xfe, 0x24, 0x47, 0x91,
                0x3f, 0x26, 0x4a, 0x46, 0x55, 0x1b, 0x13, 0xd4, 0x79, 0x90, 0x60, 0x71, 0x87, 0xe7,
                0x6c, 0x00,
            ],
        ],
        [
            [
                0x7e, 0x75, 0x76, 0xbc, 0xc2, 0x39, 0xbb, 0x44, 0x2d, 0x15, 0x31, 0x0d, 0x45, 0x00,
                0x51, 0x44, 0x9a, 0x03, 0x6e, 0x0d, 0x9a, 0xae, 0xe6, 0x90, 0xbf, 0x52, 0x2c, 0x7f,
                0x16, 0x00,
            ],
            [
                0x29, 0xad, 0xd3, 0xf7, 0x45, 0x82, 0x5d, 0x77, 0xf4, 0x1c, 0xa3, 0x69, 0x8c, 0xb8,
                0x55, 0xc9, 0x44, 0xcc, 0x53, 0xb4, 0x80, 0xdf, 0x07, 0x6f, 0x35, 0x13, 0x31, 0xa6,
                0xad, 0x00,
            ],
            [
                0x95, 0x90, 0xcd, 0x8c, 0xe7, 0x40, 0x66, 0x1b, 0x20, 0x0a, 0xf8, 0x6c, 0xae, 0x84,
                0x8f, 0x3a, 0x8b, 0x45, 0x0b, 0x04, 0x80, 0xd2, 0x99, 0x95, 0xb8, 0x27, 0x7d, 0xa0,
                0xf1, 0x01,
            ],
            [
                0x91, 0x06, 0x38, 0x14, 0xa9, 0xc4, 0x4f, 0x89, 0x3a, 0x74, 0xf5, 0xf0, 0xb4, 0x51,
                0xfd, 0x95, 0x1c, 0xcd, 0xe8, 0xd0, 0xa3, 0x75, 0xb0, 0xb2, 0x0f, 0x40, 0xd9, 0xc0,
                0x27, 0x00,
            ],
        ],
        [
            [
                0x5c, 0x5f, 0xee, 0xab, 0x3c, 0x79, 0x6d, 0xbc, 0xb3, 0x6c, 0xc3, 0x07, 0x57, 0xfd,
                0x5e, 0x0a, 0xba, 0x33, 0x47, 0xd7, 0x75, 0xa7, 0x86, 0x39, 0xe0, 0x72, 0xa8, 0xe9,
                0xe9, 0x00,
            ],
            [
                0x70, 0x36, 0xb9, 0x7e, 0xa3, 0x63, 0x83, 0xa2, 0xa1, 0x97, 0x4e, 0x69, 0x95, 0xfc,
                0xf6, 0x0a, 0x06, 0x02, 0xa5, 0x8c, 0x5c, 0x62, 0xc8, 0x37, 0x8e, 0xb5, 0x08, 0x18,
                0x93, 0x00,
            ],
            [
                0x26, 0x08, 0x88, 0x99, 0x4c, 0x06, 0xd3, 0xc4, 0xd5, 0x0b, 0x8a, 0xb6, 0x51, 0x91,
                0xbe, 0x02, 0xb2, 0x89, 0x96, 0xe3, 0x6a, 0xc9, 0x08, 0x0d, 0x94, 0xab, 0xb0, 0xab,
                0x98, 0x01,
            ],
            [
                0x13, 0xc3, 0x12, 0x20, 0x1e, 0x8e, 0x12, 0x2a, 0x8d, 0xf3, 0x3e, 0xcd, 0x35, 0x6c,
                0xc8, 0x16, 0xdc, 0x53, 0xa3, 0x1e, 0x94, 0x4d, 0xde, 0xf6, 0x20, 0x33, 0xd0, 0x36,
                0x10, 0x01,
            ],
        ],
        [
            [
                0xc0, 0x5b, 0x17, 0xd2, 0x86, 0xc3, 0xdb, 0xa9, 0xa9, 0x91, 0x33, 0xcb, 0x78, 0x93,
                0xbf, 0xfe, 0x7f, 0x53, 0x98, 0x87, 0x89, 0x10, 0x7b, 0x95, 0x36, 0x50, 0x84, 0xd3,
                0x80, 0x01,
            ],
            [
                0x0e, 0x89, 0x7b, 0xc7, 0x40, 0x87, 0x8f, 0x6f, 0xd1, 0x45, 0x33, 0x20, 0x15, 0x8a,
                0x8f, 0x7d, 0x26, 0xe9, 0x50, 0x81, 0xc2, 0xbd, 0xeb, 0xcd, 0x8e, 0x9c, 0xec, 0x1a,
                0x3f, 0x00,
            ],
            [
                0xc0, 0x84, 0x8d, 0x92, 0xf0, 0x32, 0xb6, 0x20, 0x51, 0xe4, 0x61, 0x68, 0x04, 0x05,
                0xf3, 0x27, 0x41, 0x5b, 0xc7, 0x53, 0x86, 0x8b, 0xd1, 0x03, 0x26, 0x18, 0x53, 0x74,
                0x82, 0x01,
            ],
            [
                0x73, 0xe7, 0x06, 0x43, 0xc3, 0x68, 0x92, 0x1e, 0x6c, 0xa1, 0x07, 0xd5, 0x8a, 0x03,
                0xec, 0x67, 0x22, 0x5c, 0x28, 0xd7, 0x11, 0xba, 0xb7, 0x36, 0xf2, 0x07, 0x6b, 0xf9,
                0xd1, 0x01,
            ],
        ],
        [
            [
                0xa7, 0x3d, 0xc0, 0xd3, 0x95, 0x82, 0xf1, 0xa7, 0xf7, 0x8c, 0xc8, 0xea, 0x26, 0x5c,
                0x66, 0xcd, 0x8a, 0x93, 0x32, 0x88, 0x9d, 0x84, 0xb3, 0x5b, 0xd4, 0x83, 0xbe, 0x62,
                0x58, 0x00,
            ],
            [
                0xb5, 0x87, 0x51, 0xe0, 0x4e, 0x21, 0xe2, 0xae, 0x63, 0x88, 0x04, 0x50, 0x46, 0xf3,
                0xf1, 0xf7, 0xcc, 0x48, 0x28, 0x54, 0x00, 0x4e, 0x7d, 0x0f, 0x21, 0xb4, 0x4e, 0xe8,
                0x55, 0x00,
            ],
            [
                0x33, 0xde, 0x7b, 0xda, 0x31, 0x3d, 0x62, 0x05, 0x96, 0x28, 0x3d, 0x74, 0x61, 0xf3,
                0xe5, 0xe4, 0x1d, 0xae, 0x66, 0x31, 0xe0, 0x57, 0x64, 0x7e, 0xa9, 0xb2, 0xda, 0x35,
                0x2f, 0x00,
            ],
            [
                0x77, 0x1d, 0x87, 0x44, 0x18, 0xd2, 0xc2, 0x18, 0x4e, 0x9e, 0x15, 0x53, 0xad, 0x3c,
                0x44, 0x64, 0x91, 0x63, 0x8c, 0xc1, 0x7f, 0x7f, 0x00, 0x1a, 0xda, 0x3b, 0x51, 0x4b,
                0xc5, 0x00,
            ],
        ],
        [
            [
                0x62, 0x16, 0xe6, 0x4a, 0x1d, 0xf6, 0x61, 0xb9, 0xb7, 0xbb, 0xee, 0x21, 0x86, 0x90,
                0x56, 0x69, 0x6a, 0xb7, 0xe1, 0xf0, 0x05, 0xd4, 0x98, 0xcb, 0x32, 0x8f, 0x2e, 0x53,
                0x66, 0x01,
            ],
            [
                0x81, 0x01, 0x52, 0xb0, 0x53, 0xa4, 0x30, 0xb3, 0x35, 0xeb, 0xe2, 0xa4, 0x1a, 0xdf,
                0x0f, 0x43, 0x12, 0x21, 0x11, 0x62, 0xb4, 0x11, 0xd3, 0x60, 0x8e, 0x6c, 0xb0, 0xca,
                0x8c, 0x01,
            ],
            [
                0xb6, 0x94, 0x64, 0xbd, 0x99, 0xc2, 0x5d, 0x56, 0xd7, 0x22, 0x83, 0x60, 0xb8, 0x07,
                0x8d, 0x34, 0x8b, 0xb5, 0xc6, 0x62, 0x1c, 0x82, 0xef, 0xe8, 0x37, 0xa2, 0x19, 0x5e,
                0x7e, 0x01,
            ],
            [
                0x55, 0x5c, 0x0c, 0xbe, 0x8d, 0x0e, 0x9c, 0x57, 0x84, 0xeb, 0x24, 0x19, 0x05, 0x60,
                0xe2, 0xc5, 0x92, 0xb6, 0x9a, 0xd3, 0xf2, 0xae, 0xd9, 0xc5, 0x62, 0xde, 0x67, 0x72,
                0x1e, 0x00,
            ],
        ],
        [
            [
                0x9d, 0x61, 0x2a, 0xd2, 0x10, 0x6f, 0x54, 0x9a, 0x2f, 0x6e, 0x37, 0x03, 0xbb, 0xf8,
                0xba, 0xca, 0x5d, 0xb7, 0x5d, 0x9e, 0xa2, 0x18, 0x3a, 0x65, 0x56, 0xf8, 0xbb, 0x7d,
                0x4d, 0x01,
            ],
            [
                0x3e, 0x99, 0x4f, 0x91, 0xfa, 0xb5, 0xde, 0x67, 0x71, 0x0f, 0x0b, 0xaf, 0xee, 0x1c,
                0x3d, 0x6a, 0x3b, 0x39, 0x2d, 0xe8, 0xbe, 0xd0, 0xcd, 0xea, 0xcb, 0x1c, 0x4d, 0x61,
                0x2c, 0x01,
            ],
            [
                0x2b, 0x54, 0x31, 0xf3, 0x93, 0x28, 0x5e, 0xaf, 0xd0, 0xb9, 0x25, 0x31, 0xf5, 0x21,
                0x16, 0x11, 0xd3, 0xe8, 0x5a, 0xee, 0x56, 0xb6, 0x80, 0x10, 0x61, 0xd4, 0xa8, 0x55,
                0x77, 0x01,
            ],
            [
                0x92, 0xfe, 0x31, 0x84, 0x46, 0x17, 0x34, 0x80, 0x8f, 0x9a, 0xb7, 0xb0, 0x45, 0x5e,
                0xf1, 0x56, 0x0d, 0x9d, 0x82, 0xd5, 0xe1, 0x89, 0x96, 0xef, 0x95, 0x1c, 0x60, 0x5b,
                0x1a, 0x01,
            ],
        ],
        [
            [
                0xb8, 0x66, 0xc2, 0x95, 0xdb, 0x1b, 0x32, 0x9b, 0xb8, 0xca, 0xcf, 0xaf, 0x0c, 0x67,
                0x78, 0x28, 0x24, 0x48, 0xb8, 0x09, 0x49, 0x60, 0xa5, 0xdd, 0xfa, 0xae, 0x8e, 0x0b,
                0xca, 0x00,
            ],
            [
                0x1f, 0x73, 0x08, 0x7d, 0x5a, 0xcc, 0x4e, 0xfb, 0x34, 0x7c, 0xf0, 0xfc, 0x53, 0x23,
                0x0c, 0xe0, 0x19, 0x97, 0x35, 0x35, 0x79, 0xc0, 0xb5, 0x02, 0x38, 0xa9, 0x62, 0xed,
                0x67, 0x01,
            ],
            [
                0x16, 0xaa, 0xdd, 0x7e, 0x55, 0x86, 0xd5, 0x95, 0xd9, 0x85, 0x7c, 0x82, 0xba, 0xdb,
                0x42, 0x6a, 0xf3, 0x35, 0xe8, 0x43, 0xc9, 0x30, 0x85, 0x41, 0xe0, 0x11, 0xe2, 0x56,
                0x3a, 0x00,
            ],
            [
                0x43, 0x68, 0x68, 0xb4, 0xb2, 0x1a, 0xf9, 0x4a, 0x77, 0x04, 0x4e, 0x2e, 0xe6, 0x85,
                0x2d, 0x2c, 0x85, 0x2e, 0xff, 0xd9, 0xd4, 0xa0, 0x9b, 0xc6, 0xdb, 0xae, 0xda, 0x6c,
                0x70, 0x00,
            ],
        ],
    ];

    fn bytes_to_coords<T: CircuitTrait>(bld: &mut T, src: &[u8; 30]) -> [usize; GF_LEN] {
        let zero = bld.zero();
        let one = bld.one();
        let mut out = [zero; GF_LEN];
        for (i, slot) in out.iter_mut().enumerate() {
            let bit = (src[i / 8] >> (i % 8)) & 1 != 0;
            *slot = if bit { one } else { zero };
        }
        out
    }

    fn make_const_point<T: CircuitTrait>(bld: &mut T, coords: &[[u8; 30]; 4]) -> CurvePoint {
        CurvePoint {
            x: bytes_to_coords(bld, &coords[0]),
            s: bytes_to_coords(bld, &coords[1]),
            z: bytes_to_coords(bld, &coords[2]),
            t: bytes_to_coords(bld, &coords[3]),
        }
    }

    fn generator_const_table<T: CircuitTrait>(bld: &mut T) -> Vec<CurvePoint> {
        GENERATOR_TABLE_W5.iter().map(|entry| make_const_point(bld, entry)).collect()
    }

    fn matches_coords(bits: &[usize; GF_LEN], src: &[u8; 30], zero: usize, one: usize) -> bool {
        bits.iter().enumerate().all(|(i, &wire)| {
            let bit = (src[i / 8] >> (i % 8)) & 1 != 0;
            let expected = if bit { one } else { zero };
            wire == expected
        })
    }

    fn is_generator_point<T: CircuitTrait>(bld: &mut T, p: &CurvePoint) -> bool {
        let zero = bld.zero();
        let one = bld.one();
        matches_coords(&p.x, &GENERATOR_X_BYTES, zero, one)
            && matches_coords(&p.s, &GENERATOR_S_BYTES, zero, one)
            && matches_coords(&p.z, &GENERATOR_Z_BYTES, zero, one)
            && matches_coords(&p.t, &GENERATOR_T_BYTES, zero, one)
    }

    /// lookup precompute table
    // indices in little-endian form
    // table: [0..2^w-1]P
    pub(crate) fn emit_lookup<T: CircuitTrait>(
        bld: &mut T,
        table: &[CurvePoint],
        indices: Vec<usize>,
    ) -> CurvePoint {
        fn mux<T: CircuitTrait>(
            bld: &mut T,
            s: &CurvePoint,
            other: &CurvePoint,
            sel: &CurvePoint,
        ) -> CurvePoint {
            let mut r = CurvePoint::identity(bld);

            for i in 0..GF_LEN {
                let d = bld.xor_wire(s.x[i], other.x[i]);
                let xd = bld.and_wire(sel.x[i], d);
                r.x[i] = bld.xor_wire(xd, s.x[i]);
            }
            for i in 0..GF_LEN {
                let d = bld.xor_wire(s.s[i], other.s[i]);
                let xd = bld.and_wire(sel.s[i], d);
                r.s[i] = bld.xor_wire(xd, s.s[i]);
            }
            for i in 0..GF_LEN {
                let d = bld.xor_wire(s.z[i], other.z[i]);
                let xd = bld.and_wire(sel.z[i], d);
                r.z[i] = bld.xor_wire(xd, s.z[i]);
            }
            for i in 0..GF_LEN {
                let d = bld.xor_wire(s.t[i], other.t[i]);
                let xd = bld.and_wire(sel.t[i], d);
                r.t[i] = bld.xor_wire(xd, s.t[i]);
            }
            r
        }

        assert!(table.len().is_power_of_two(), "table length must be a power-of-two");
        let mut level: Vec<CurvePoint> = table.to_vec();

        let mut bit = 0;
        while level.len() > 1 {
            let sel_mask = CurvePoint {
                x: [indices[bit]; GF_LEN],
                s: [indices[bit]; GF_LEN],
                z: [indices[bit]; GF_LEN],
                t: [indices[bit]; GF_LEN],
            };
            let mut next = Vec::<CurvePoint>::with_capacity(level.len() / 2);
            for j in 0..(level.len() / 2) {
                let a = &level[2 * j];
                let b = &level[2 * j + 1];
                next.push(mux(bld, a, b, &sel_mask));
            }
            level = next;
            bit += 1;
        }
        level[0]
    }

    // generate precompute table
    pub(crate) fn emit_precompute_table<T: CircuitTrait>(
        bld: &mut T,
        p: &CurvePoint,
        w: usize,
    ) -> Vec<CurvePoint> {
        if w == 5 && is_generator_point(bld, p) {
            return generator_const_table(bld);
        }

        let table_size = 1 << w;
        let iden = CurvePoint::identity(bld);

        let mut table = Vec::with_capacity(table_size);
        table.push(iden);

        // 1. Precompute basis points P_j = frob^j(P)
        let mut basis_points = Vec::with_capacity(w);
        basis_points.push(*p); // basis_points[0] = P = frob^0(P)
        for _ in 1..w {
            let next_p = emit_point_frob(bld, basis_points.last().unwrap());
            basis_points.push(next_p);
        }

        // 2. Build the full table iteratively
        for (k, basis_point_i) in basis_points.iter().enumerate().take(w) {
            let current_size = 1 << k;

            // For each point already in the table, compute a new point by adding the k-th basis point.
            // This extends the table from size `current_size` to `2 * current_size`.
            for i in 0..current_size {
                let new_point = Template::emit_point_add_custom(bld, &table[i], basis_point_i);
                table.push(new_point);
            }
        }

        table
    }

    // generate precompute table for decompose triple scalar multiplication
    pub(crate) fn emit_precompute_d3_table<T: CircuitTrait>(
        bld: &mut T,
        p0: &CurvePoint,
        p1: &CurvePoint,
        p2: &CurvePoint,
    ) -> Vec<CurvePoint> {
        let bs = vec![
            [0, 0, 0],
            [1, 0, 0],
            [0, 1, 0],
            [1, 1, 0],
            [0, 0, 1],
            [1, 0, 1],
            [0, 1, 1],
            [1, 1, 1],
        ];

        let table_size = bs.len();
        let iden = CurvePoint::identity(bld);

        let mut table = Vec::with_capacity(table_size);
        table.push(iden);

        for i in 1..table_size {
            let temp_point = add_2_points_with_selects(bld, bs[i][0], p0, bs[i][1], p1);
            let res_point = add_2_points_with_selects(bld, 1, &temp_point, bs[i][2], &p2,);
            table.push(res_point);
        }
        table
    }

    fn add_2_points_with_selects<T: CircuitTrait>(
        bld: &mut T,
        select0: usize,
        p0: &CurvePoint,
        select1: usize,
        p1: &CurvePoint,
    ) -> CurvePoint {
        if select0 == 0 && select1 == 0 {
            return CurvePoint::identity(bld);
        }
        if select0 == 0 {
            return p1.clone();
        }
        if select1 == 0 {
            return p0.clone();
        }
        Template::emit_point_add_custom(bld, p0, p1)
        // emit_point_add(bld, p0, p1)
    }

    #[cfg(test)]
    mod test {
        use std::time::Instant;

        use super::super::super::{
            builder::CircuitTrait,
            curve_ref::{point_add, point_frob},
        };
        use num_bigint::{BigUint, RandomBits};
        use num_traits::FromPrimitive;
        use rand::Rng;

        use super::super::super::{
            builder::CircuitAdapter,
            curve_ckt::CurvePoint,
            curve_ref::CurvePointRef as InnerPointRef,
            // point_scalar_mul::precompute_table,
            curve_scalar_mul_ckt::precompute_table::emit_lookup,
            gf_ref::{gfref_mul, gfref_to_bits},
        };

        use super::emit_precompute_table;

        pub(crate) fn ref_precompute_table(p: &InnerPointRef, w: usize) -> Vec<InnerPointRef> {
            let table_size = 1 << w;

            if w == 0 {
                // For a 0-bit window, the table only contains the identity point.
                return vec![InnerPointRef::identity()];
            }

            let mut table = Vec::with_capacity(table_size);
            table.push(InnerPointRef::identity());

            // 1. Precompute basis points P_j = frob^j(P)
            let mut basis_points = Vec::with_capacity(w);
            basis_points.push(p.clone()); // basis_points[0] = P = frob^0(P)
            for _ in 1..w {
                // basis_points[i] = frob(basis_points[i-1])
                let next_p = point_frob(basis_points.last().unwrap());
                basis_points.push(next_p);
            }

            // 2. Build the full table iteratively
            for (k, basis_point) in basis_points.iter().enumerate().take(w) {
                let current_size = 1 << k;

                // For each point already in the table, compute a new point by adding the k-th basis point.
                // This extends the table from size `current_size` to `2 * current_size`.
                for i in 0..current_size {
                    let new_point = point_add(&table[i], basis_point);
                    table.push(new_point);
                }
            }

            table
        }

        #[test]
        #[ignore]
        fn test_emit_precompute_table() {
            let w = 2;
            let pt_ref = InnerPointRef::generator();
            let tables_ref = ref_precompute_table(&pt_ref, w);

            let mut bld = CircuitAdapter::default();
            let pt_gen = CurvePoint::generator(&mut bld);

            let mut witness = Vec::<bool>::new();
            for pt in [pt_ref.x, pt_ref.s, pt_ref.z, pt_ref.t] {
                let pt_bits = gfref_to_bits(&pt);
                witness.extend_from_slice(&pt_bits);
            }

            let st = Instant::now();
            let tables_ckt = emit_precompute_table(&mut bld, &pt_gen, w);
            let el = st.elapsed();
            let stats = bld.gate_counts();
            println!("{stats}");
            println!("emit_precompute_table took {} seconds ", el.as_secs());
            assert_eq!(tables_ref.len(), tables_ckt.len());

            let wires = bld.eval_gates(&witness);

            for i in 0..tables_ref.len() {
                let ckt_x: Vec<bool> = tables_ckt[i].x.iter().map(|id| wires[*id]).collect();
                let ref_x: Vec<bool> = gfref_to_bits(&tables_ref[i].x).to_vec();
                assert_eq!(ckt_x, ref_x);
                let ckt_x: Vec<bool> = tables_ckt[i].s.iter().map(|id| wires[*id]).collect();
                let ref_x: Vec<bool> = gfref_to_bits(&tables_ref[i].s).to_vec();
                assert_eq!(ckt_x, ref_x);
                let ckt_x: Vec<bool> = tables_ckt[i].z.iter().map(|id| wires[*id]).collect();
                let ref_x: Vec<bool> = gfref_to_bits(&tables_ref[i].z).to_vec();
                assert_eq!(ckt_x, ref_x);
                let ckt_x: Vec<bool> = tables_ckt[i].t.iter().map(|id| wires[*id]).collect();
                let ref_x: Vec<bool> = gfref_to_bits(&tables_ref[i].t).to_vec();
                assert_eq!(ckt_x, ref_x);
            }
        }

        #[test]
        fn test_emit_lookup_table() {
            fn random_point() -> InnerPointRef {
                let mut rng = rand::thread_rng();
                let x = rng.sample(RandomBits::new(232));
                let s = rng.sample(RandomBits::new(232));
                let z = rng.sample(RandomBits::new(232));

                let t = gfref_mul(&x, &z);

                InnerPointRef { x, s, z, t }
            }

            let window = 5;

            let table_len = 1 << window;
            let mut tables_ref = Vec::with_capacity(table_len);
            let mut tables_ckt = Vec::with_capacity(table_len);

            let mut bld = CircuitAdapter::default();

            let mut rng = rand::thread_rng();
            let lookup_index: u8 = rng.r#gen::<u8>() as u8 % table_len as u8;
            let lookup_index_bits = gfref_to_bits(&BigUint::from_u8(lookup_index).unwrap());
            let lookup_index_bits = lookup_index_bits[0..window].to_vec();

            println!("lookup_index_bits {:?} and lookup index {}", lookup_index_bits, lookup_index);
            let mut witness = Vec::<bool>::new();
            let mut lookup_index_bit_labels = vec![];
            for bit in lookup_index_bits.iter().take(window) {
                lookup_index_bit_labels.push(bld.fresh_one());
                witness.push(*bit);
            }

            for _ in 0..table_len {
                let rt = random_point();
                tables_ref.push(rt.clone());

                let x = gfref_to_bits(&rt.x);
                let s = gfref_to_bits(&rt.s);
                let z = gfref_to_bits(&rt.z);
                let t = gfref_to_bits(&rt.t);

                let x = x.map(|xi| if xi { bld.one() } else { bld.zero() });
                let s = s.map(|xi| if xi { bld.one() } else { bld.zero() });
                let z = z.map(|xi| if xi { bld.one() } else { bld.zero() });
                let t = t.map(|xi| if xi { bld.one() } else { bld.zero() });

                let pt = CurvePoint { x, s, z, t };
                tables_ckt.push(pt);
            }

            let entry_bits = emit_lookup(&mut bld, &tables_ckt, lookup_index_bit_labels);

            let stats = bld.gate_counts();
            println!("{stats}");
            let wires = bld.eval_gates(&witness);
            let ckt_x: Vec<bool> = entry_bits.x.iter().map(|id| wires[*id]).collect();
            let ckt_s: Vec<bool> = entry_bits.s.iter().map(|id| wires[*id]).collect();
            let ckt_z: Vec<bool> = entry_bits.z.iter().map(|id| wires[*id]).collect();
            let ckt_t: Vec<bool> = entry_bits.t.iter().map(|id| wires[*id]).collect();

            for (i, table_i) in tables_ref.iter().enumerate() {
                let ref_x: Vec<bool> = gfref_to_bits(&table_i.x).to_vec();
                if i == lookup_index as usize {
                    assert_eq!(ckt_x, ref_x);
                } else {
                    assert_ne!(ckt_x, ref_x);
                }
                let ref_s: Vec<bool> = gfref_to_bits(&table_i.s).to_vec();
                if i == lookup_index as usize {
                    assert_eq!(ckt_s, ref_s);
                } else {
                    assert_ne!(ckt_s, ref_s);
                }
                let ref_z: Vec<bool> = gfref_to_bits(&table_i.z).to_vec();
                if i == lookup_index as usize {
                    assert_eq!(ckt_z, ref_z);
                } else {
                    assert_ne!(ckt_z, ref_z);
                }
                let ref_t: Vec<bool> = gfref_to_bits(&table_i.t).to_vec();
                if i == lookup_index as usize {
                    assert_eq!(ckt_t, ref_t);
                } else {
                    assert_ne!(ckt_t, ref_t);
                }
            }
        }
    }
}

/// Windowed tau-adic point scalar multiplication
// TODO: Use PRTNAF for lower gate counts
pub(crate) mod point_scalar_mul {
    use crate::circuits::sect233k1::curve_scalar_mul_ckt::precompute_table::emit_precompute_d3_table;
    use super::super::{
        builder::{CircuitTrait, Template},
        curve_ckt::{CurvePoint, emit_point_frob},
        fr_ckt::Fr,
    };

    use super::{
        TAU_ADIC_LEN,
        precompute_table::{emit_lookup, emit_precompute_table},
        tau_adic_repr::emit_tau_adic_repr_bits,
    };

    pub(crate) fn emit_mul_windowed_tau<T: CircuitTrait>(
        bld: &mut T,
        k: &Fr,
        point_p: &CurvePoint,
        w: usize,
    ) -> CurvePoint {
        let mut tau_bits = emit_tau_adic_repr_bits(bld, k);
        tau_bits.reverse(); // start from msb

        let table = emit_precompute_table(bld, point_p, w);

        let mut r = CurvePoint::identity(bld);

        for i in (0..TAU_ADIC_LEN).step_by(w) {
            for _ in 0..w {
                r = emit_point_frob(bld, &r);
            }

            let mut lidx = tau_bits[i..i + w].to_vec();
            lidx.reverse(); // into little endian form undoes `tau_bits.reverse()`, tau_bits itself was in little-endian when received as input

            let q = emit_lookup(bld, &table, lidx);

            r = Template::emit_point_add_custom(bld, &r, &q);
        }
        r
    }

    // Compute [x1]P1 + x2[P2] + x3[P3].
    pub(crate) fn emit_triple_scalar_multiplication<T: CircuitTrait>(
        bld: &mut T,
        k1: &Fr,
        p1: &CurvePoint,
        k2: &Fr,
        p2: &CurvePoint,
        k3: &Fr,
        p3: &CurvePoint,
    ) -> CurvePoint {
        // precompute table for 3 points
        let table = emit_precompute_d3_table(bld, p1, p2, p3);

        let mut r = CurvePoint::identity(bld);
        //Todo: set 155 as Global variable
        for i in 0..155 {
            r = Template::emit_point_add_custom(bld, &r, &r); // r = r * 2
            // get the msb i-th bit of k1, k2, k3
            // expected that k1, k2, k3 <= 2^155 after decomposition
            let lidx = vec![k1[154 - i], k2[154 - i], k3[154 - i]];
            let t_i = emit_lookup(bld, &table, lidx);
            r = Template::emit_point_add_custom(bld, &r, &t_i);
        }
        r
    }

    #[cfg(test)]
    mod test {
        use std::thread::sleep;
        use std::time::Instant;

        use num_bigint::{BigUint, RandomBits};
        use rand::Rng;

        use super::*;
        use crate::circuits::sect233k1::builder::{CircuitAdapter, CircuitTrait};
        use crate::circuits::sect233k1::curve_ckt::{emit_point_add, CompressedCurvePoint, CompressedCurvePointRef};
        use crate::circuits::sect233k1::curve_ref::{point_add, CurvePointRef as InnerPointRef, CurvePointRef};
        use crate::circuits::sect233k1::curve_ref::point_scalar_multiplication;
        use crate::circuits::sect233k1::fr_ref::frref_to_bits;
        use crate::circuits::sect233k1::gf_ref::{bits_to_gfref, gfref_to_bits};


        #[test]
        // #[ignore]
        fn test_decompose_msm() {
            let p1 = InnerPointRef::generator();
            let p2 = InnerPointRef::generator();
            let expected_output = InnerPointRef::identity(); // = 0

            let k1_be_bytes = vec![0, 0, 0, 43, 52, 84, 176, 75, 70, 122, 59, 238, 90, 152, 55, 97, 148, 25, 71, 127, 67, 98, 248, 218, 190, 136, 214, 182, 47, 48, 167, 1];
            let k2_be_bytes = vec![0, 0, 0, 89, 114, 117, 208, 3, 249, 12, 114, 129, 55, 155, 32, 198, 179, 51, 74, 131, 206, 34, 109, 103, 90, 135, 236, 251, 190, 106, 233, 253];
            let x1_be_bytes = vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 152, 120, 76, 232, 237, 6, 47, 82, 175, 113, 22, 122, 179, 146, 233, 97, 219, 67, 219];
            let x2_be_bytes = vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 21, 10, 39, 160, 144, 191, 138, 213, 234, 230, 99, 71, 68, 57, 14, 197, 139, 238, 173];
            let x3_be_bytes = vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 14, 188, 252, 244, 161, 199, 207, 181, 64, 226, 222, 43, 143, 181, 210, 199, 178, 168];
            let x1 = BigUint::from_bytes_be(&x1_be_bytes);
            let x2 = BigUint::from_bytes_be(&x2_be_bytes);
            let x3 = BigUint::from_bytes_be(&x3_be_bytes);
            let k1 = BigUint::from_bytes_be(&k1_be_bytes);
            let k2 = BigUint::from_bytes_be(&k2_be_bytes);

            let p3_1 = point_scalar_multiplication(&k1, &p1);
            let p3_2 = point_scalar_multiplication(&k2, &p2);
            let p3 = point_add(&p3_1, &p3_2);

            let expected_p3_ref: CompressedCurvePointRef = [7, 248, 88, 88, 199, 102, 44, 116, 8, 10, 226, 221, 2, 63, 242, 217, 247, 125, 89, 183, 181, 28, 67, 76, 246, 66, 172, 123, 248, 0];
            let expected_p3 = CurvePointRef::from_compressed_point(&expected_p3_ref).0;
            assert_eq!(p3, expected_p3);

            // ++++++
            let mut bld = CircuitAdapter::default();
            let mut witness = Vec::<bool>::new();
            let x1witness = frref_to_bits(&x1);
            let x2witness = frref_to_bits(&x2);
            let x3witness = frref_to_bits(&x3);

            let p1witness: Vec<bool> = [&p1.x, &p1.s, &p1.z, &p1.t]
                .iter()
                .flat_map(|k| {
                    let kb: Vec<bool> = gfref_to_bits(k).to_vec();
                    kb
                })
                .collect();

            let p2witness: Vec<bool> = [&p2.x, &p2.s, &p2.z, &p2.t]
                .iter()
                .flat_map(|k| {
                    let kb: Vec<bool> = gfref_to_bits(k).to_vec();
                    kb
                })
                .collect();

            let p3witness: Vec<bool> = [&p3.x, &p3.s, &p3.z, &p3.t]
                .iter()
                .flat_map(|k| {
                    let kb: Vec<bool> = gfref_to_bits(k).to_vec();
                    kb
                })
                .collect();

            let x1labels: Fr = bld.fresh();
            let x2labels: Fr = bld.fresh();
            let x3labels: Fr = bld.fresh();
            let p1labels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };
            let p2labels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };
            let p3labels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };

            witness.extend_from_slice(&x1witness);
            witness.extend_from_slice(&x2witness);
            witness.extend_from_slice(&x3witness);
            witness.extend_from_slice(&p1witness);
            witness.extend_from_slice(&p2witness);
            witness.extend_from_slice(&p3witness);

            println!("emit_triple_scalar_multiplication");
            let st = Instant::now();
            let out_bits = emit_triple_scalar_multiplication(&mut bld, &x1labels, &p1labels, &x2labels, &p2labels, &x3labels, &p3labels);
            let st = st.elapsed();
            println!("emit_triple_scalar_multiplication took {} seconds", st.as_secs());

            // bld.write_bristol_periodic("psm4.bristol").unwrap(); // uncomment if you want to dump to bristol file

            let stats = bld.gate_counts();
            println!("{stats}");

            let wires = bld.eval_gates(&witness);

            println!("validating output");
            let ckt_x = out_bits.x.map(|id| wires[id]);
            let ckt_s = out_bits.s.map(|id| wires[id]);
            let ckt_z = out_bits.z.map(|id| wires[id]);
            let ckt_t = out_bits.t.map(|id| wires[id]);

            let ckt_out = InnerPointRef {
                x: bits_to_gfref(&ckt_x),
                s: bits_to_gfref(&ckt_s),
                z: bits_to_gfref(&ckt_z),
                t: bits_to_gfref(&ckt_t),
            };

            assert_eq!(ckt_out, expected_output);

            // build circuit
            println!("build circuit");
            let mut circuit = bld.build(&witness);
            let start = Instant::now();
            let total_gates = circuit.gate_counts();
            println!("gate_counts time: {:?}", start.elapsed());
            total_gates.print();
        }

        // ignore because of long running test
        #[test]
        #[ignore]
        fn test_msm() {
            let window = 5;
            let gref = InnerPointRef::generator();

            let mut rng = rand::thread_rng();
            let k: BigUint = rng.sample(RandomBits::new(231));

            let out_ref = point_scalar_multiplication(&k, &gref);

            // +++++++++++
            let mut bld = CircuitAdapter::default();
            let mut witness = Vec::<bool>::new();

            let kwitness = frref_to_bits(&k);
            let ptwitness: Vec<bool> = [&gref.x, &gref.s, &gref.z, &gref.t]
                .iter()
                .flat_map(|k| {
                    let kb: Vec<bool> = gfref_to_bits(k).to_vec();
                    kb
                })
                .collect();

            let klabels: Fr = bld.fresh();
            let ptlabels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };

            witness.extend_from_slice(&kwitness);
            witness.extend_from_slice(&ptwitness);

            println!("emit_mul_windowed_tau");
            let st = Instant::now();

            let out_bits = emit_mul_windowed_tau(&mut bld, &klabels, &ptlabels, window);

            let st = st.elapsed();
            println!("emit_mul_windowed_tau took {} seconds", st.as_secs());

            // bld.write_bristol_periodic("psm4.bristol").unwrap(); // uncomment if you want to dump to bristol file

            let stats = bld.gate_counts();
            println!("{stats}");

            let wires = bld.eval_gates(&witness);

            println!("validating input witness");
            let kwitness_calc: Vec<bool> = klabels.iter().map(|id| wires[*id]).collect();
            let ptwitness_x: Vec<bool> = ptlabels.x.iter().map(|id| wires[*id]).collect();
            let ptwitness_s: Vec<bool> = ptlabels.s.iter().map(|id| wires[*id]).collect();
            let ptwitness_z: Vec<bool> = ptlabels.z.iter().map(|id| wires[*id]).collect();
            let ptwitness_t: Vec<bool> = ptlabels.t.iter().map(|id| wires[*id]).collect();
            let pwitness_calc: Vec<bool> = vec![ptwitness_x, ptwitness_s, ptwitness_z, ptwitness_t]
                .into_iter()
                .flatten()
                .collect();
            assert_eq!(kwitness_calc, kwitness);
            assert_eq!(pwitness_calc, ptwitness);

            println!("validating output");
            let ckt_x = out_bits.x.map(|id| wires[id]);
            let ckt_s = out_bits.s.map(|id| wires[id]);
            let ckt_z = out_bits.z.map(|id| wires[id]);
            let ckt_t = out_bits.t.map(|id| wires[id]);

            let ckt_out = InnerPointRef {
                x: bits_to_gfref(&ckt_x),
                s: bits_to_gfref(&ckt_s),
                z: bits_to_gfref(&ckt_z),
                t: bits_to_gfref(&ckt_t),
            };

            assert_eq!(ckt_out, out_ref);
        }

        // Todo: remove after finish decompose msm
        #[test]
        // This test just printout the circuit size for triple scalar multiplication
        fn test_decompose_circuit_size() {
            // ++++++
            let mut bld = CircuitAdapter::default();
            let x1labels: Fr = bld.fresh();
            let x2labels: Fr = bld.fresh();
            let x3labels: Fr = bld.fresh();
            let p1labels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };
            let p2labels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };
            let p3labels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };

            println!("emit_triple_scalar_multiplication");
            let st = Instant::now();
            let out_bits = emit_triple_scalar_multiplication(&mut bld, &x1labels, &p1labels, &x2labels, &p2labels, &x3labels, &p3labels);
            let st = st.elapsed();
            println!("emit_triple_scalar_multiplication took {} seconds", st.as_secs());
            let stats = bld.gate_counts();
            println!("{stats}");
        }

        // Todo: remove after finish decompose msm
        #[test]
        // This test just printout the circuit size for tau-adic scalar multiplication
        fn test_tau_adic_sm_circuit_size() {
            let window = 5;
            let p1 = InnerPointRef::generator();
            let p2 = InnerPointRef::generator();

            let mut rng = rand::thread_rng();
            let k1: BigUint = rng.sample(RandomBits::new(231));
            let k2: BigUint = rng.sample(RandomBits::new(231));

            let out_ref_1 = point_scalar_multiplication(&k1, &p1);
            let out_ref_2 = point_scalar_multiplication(&k2, &p2);
            let out_ref = point_add(&out_ref_1, &out_ref_2);

            // +++++++++++
            let mut bld = CircuitAdapter::default();
            let u0labels: Fr = bld.fresh();
            let v0labels: Fr = bld.fresh();
            let glabels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };
            let gklabels: CurvePoint =
                CurvePoint { x: bld.fresh(), s: bld.fresh(), z: bld.fresh(), t: bld.fresh() };

            println!("emit_mul_windowed_tau");
            let st = Instant::now();

            let u0_g_labels = emit_mul_windowed_tau(&mut bld, &u0labels, &glabels, window);
            let v0_gk_labels = emit_mul_windowed_tau(&mut bld, &v0labels, &gklabels, window);
            let res_labels = emit_point_add(&mut bld, &u0_g_labels, &v0_gk_labels);

            let st = st.elapsed();
            println!("emit_mul_windowed_tau took {} seconds", st.as_secs());
            let stats = bld.gate_counts();
            println!("{stats}");

            let mut witness = Vec::<bool>::new();
            let k1witness = frref_to_bits(&k1);
            let k2witness = frref_to_bits(&k2);
            let p1witness: Vec<bool> = [&p1.x, &p1.s, &p1.z, &p1.t]
                .iter()
                .flat_map(|k| {
                    let kb: Vec<bool> = gfref_to_bits(k).to_vec();
                    kb
                })
                .collect();
            let p2witness: Vec<bool> = [&p2.x, &p2.s, &p2.z, &p2.t]
                .iter()
                .flat_map(|k| {
                    let kb: Vec<bool> = gfref_to_bits(k).to_vec();
                    kb
                })
                .collect();
            witness.extend_from_slice(&k1witness);
            witness.extend_from_slice(&k2witness);
            witness.extend_from_slice(&p1witness);
            witness.extend_from_slice(&p2witness);

            println!("build circuit");
            let mut circuit = bld.build(&witness);
            let start = Instant::now();
            let total_gates = circuit.gate_counts();
            println!("gate_counts time: {:?}", start.elapsed());
            total_gates.print();
        }
    }
}
